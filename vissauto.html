<!DOCTYPE html>

<html>
	<head>
        <title>VISS Web Client - Automatic Requester</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="icon" href="images/favicon.ico">
        <link rel="stylesheet" href="styles/menu.css" type="text/css">
		<link rel="stylesheet" href="styles/general.css" type="text/css">
        <script src = "scripts/js/encoding.js"></script>
        <script src = "scripts/js/clientscripts.js"></script>
        <script src = "scripts/js/logger.js"></script>
        <script src = "scripts/js/encoding.js"></script>
        <script src = "scripts/js/tokenhandler.js"></script>
        <script src = "scripts/js/autoclient.js"></script>
	</head>
	<body>
        <script src = "scripts/js/menu.js"></script>
		<h2>VISS Automatic Client</h2>

        <div id = "client_context" class = "vert_select_list row">
            <p class="subject">Client Context</p>
            <label for="user_role">User Role</label> 
            <select id = "user_role" name = "user_role">
                <option value = "Independent">Independent</option>
                <option value = "OEM">OEM</option>
                <option value = "Dealer">Dealer</option>
                <option value = "Owner">Owner</option>
                <option value = "Driver">Driver</option>
                <option value = "Passenger">Passenger</option>
            </select>
            <label for="app_role">App Role</label>
            <select id="app_role" name = "app_role">
                <option value = "OEM">OEM</option>
                <option value = "Third party">Third Party</option>
            </select>
            <label for="dev_role">Device Role</label>
            <select id="dev_role" name = "dev_role">
                <option value = "Cloud">Cloud</option>
                <option value = "Nomadic">Nomadic</option>
                <option value = "Vehicle">Vehicle</option>
            </select>
            <label for = "protocol_flow">Protocol Flow</label>
            <select id="key_role" name = "key_role">
                <option value = "None">Short Term</option>
                <option value = "RS256">Long Term: RS256</option>
                <option value = "ES256">Long Term: ES256</option>
            </select> 
            <button onclick="setClientData()" class="arrow_button"><span>Set</span></button>
        </div>

        <div id = "request_options" class="vert_select_list row">
            <p class="subject">Request</p>
            <div class = "column" style="width: 15%;">
                <label for = "protocol">Protocol</label>
                <br><select id = "protocol" name = "protocol">
                    <option value = "HTTP">HTTP</option>
                    <option value = "WS">WebSocket</option>
                    <option value = "MQTT">MQTT</option>
                </select>
                <label for = "method">Method</label>
                <br><select id = "method" name = "method"></select>
                <div style="font-size: 10px;"> Note: Only Some Methods Supported at the moment </div>
                <br>
                <input type="checkbox" id="log_switch" checked> <span>Logs</span>
                <input type="checkbox" id="at_switch" checked> <span>AT</span>
                <br>
                <button onclick="sendVissReq()" class="arrow_button"><span>Send</span></button>  
            </div>

            <div class="column" id = "url_col" style="width: 15%;">
                <div id = "req_url">
                    <label for = "req0">Request URL</label>
                    <br><select id = "req0" name = "token">
                        <option value = "">-</option>
                    </select>
                    <select id = "req1" name = "token" style="display: none;"></select>
                    <select id = "req2" name = "token" style="display: none;"></select>
                    <select id = "req3" name = "token" style="display: none;"></select>
                    <select id = "req4" name = "token" style="display: none;"></select>
                    <select id = "req5" name = "token" style="display: none;"></select>
                    <select id = "req6" name = "token" style="display: none;"></select>
                    <select id = "req7" name = "token" style="display: none;"></select>
                    <select id = "req8" name = "token" style="display: none;"></select>
                    <select id = "req9" name = "token" style="display: none;"></select>
                    <select id = "req10" name = "token" style="display: none;"></select>
                    <select id = "req11" name = "token" style="display: none;"></select>
                    <select id = "req12" name = "token" style="display: none;"></select>
                    <select id = "req13" name = "token" style="display: none;"></select>
                    <select id = "req14" name = "token" style="display: none;"></select>
                    <select id = "req15" name = "token" style="display: none;"></select>
                </div> 
                <div id = "update_div" style="display: none;">
                    <label for = "update_input">Update Value</label>
                    <input type = "text" id = "update_input">
                </div>           
            </div>

            <div class="column" id = "subs_id_col" style="width: 15%; display: none;">
                <label for = "sub_id">Subscription ID</label>
                <input type = "text" id = "sub_id">
            </div>
            
            <div class = "column" id = "filter_col" style="width: 15%; display: none;">
                <label for = "filters">Filters</label>
                <dl id = "filters">
                    <dt id = "timebased_div">
                        <label for = "timebased_filt">Timebased</label>
                        <input type="radio" id="timebased_filt" name = "filt_radio" unchecked>
                        <div id = "timebased_filt_input" style="display: none;">
                            <label for = "timebased_filt_period">Period (ms): </label>
                            <input type = "text" id = "timebased_filt_period" placeholder="time between updates" >
                        </div>
                    </dt>
                    <dt id = "path_div">
                        <label for = "paths_filt">Paths</label> 
                        <input type="radio" id = "paths_filt" name = "filt_radio" unchecked>
                        <div id = "paths_filt_input" style="display: none;">
                            <input type = "text" id = "path_filt_1" placeholder="path1">
                            <input type = "text" id = "path_filt_2" placeholder="path2">
                            <input type = "text" id = "path_filt_3" placeholder="path3">
                        </div>
                    </dt>
                    <dt id = "change_div">
                        <label for = "change_filt">Change</label>
                        <input type="radio" id="change_filt" name = "filt_radio" unchecked>
                        <div id = "change_filt_input" style="display: none;">
                            <label for = "change_filt_operator">Operator:</label>
                            <select id = "change_filt_operator" name = "change_filt_operator">
                                <option value = "gt">Greather than (false -> true)</option>
                                <option value = "lt">Lower than (true -> false)</option>
                                <option value = "ne">Not equal (both)</option>
                                <option value = "gte">Greather than or equal</option>
                                <option value = "lte">Lower than or equal</option>
                            </select>
                            <label for = "change_filt_difference">Difference: </label>
                            <input type = "text" id = "change_filt_difference">
                        </div>
                    </dt>
                    <dt id = "none_div">
                        <label for = "no_filt">None</label>
                        <input type = "radio" id = "no_filt" name = "filt_radio" checked>
                    </dt>
                </dl>                    
            </div>

            <div class="column" style = "width: 50%; float: right" >
                <div class="data_box_bordered" id="logs">
                    <p class="subject">Logs 
                        <button onclick="logReset()">Reset</button> 
                    </p> 
                    <p id="log_data" class="data" style="display: block; overflow-y: scroll; height: 200px;"></p>
                </div> 
            </div>
        </div> 

        <div class = "message_list row" id = "message_list">
            <p class = "subject">Response List</p>
            <div class = "messages" id = "messages"></div>
        </div>

        
        <!---

                sssssss ccccccc rrrrrrr  ii  ppppppp ttttttt sssssss 
                ss      cc      rr   rr  ii  pp   pp   ttt   ss      
                sssssss cc      rrrrrrr  ii  ppppppp   ttt   sssssss 
                     ss cc      rr rr    ii  pp         tt        ss 
                sssssss ccccccc rr  rrr  ii  pp         ttt  sssssss 

        -->

        <!-- Client Data-->
        <script>
            function setClientData(){
                clientUser = document.getElementById("user_role").value;
                clientApp = document.getElementById("app_role").value;
                clientDevice = document.getElementById("dev_role").value;
                clientContext = clientUser + "+" + clientApp + "+" + clientDevice;
                clientKey = document.getElementById("key_role").value;
                // Gets the Access Token List for the context
                initContextAtList(clientContext);
                initContextAgtList(clientContext);
                initClientPurposeList();
                initPath();
            }
        </script>

        <!-- Print the path giving information about the possibilities with the signals -->
        <script>
        function initPath(){
            document.getElementById("req0").innerHTML = '<option value = "">-</option>';
            for (let key in dataTree){
                document.getElementById("req0").insertAdjacentHTML("beforeend", '<option value = "' + key + '">' + key + '</option>');
            }
            for (let i = 1; i <= 15; i++){ // Deletes all paths after the first
                document.getElementById("req"+i).style.display = "none";
                document.getElementById("req"+i).innerHTML = "";
                document.getElementById("req"+i).value = "";
            }
        }

        // Adds listener for a path change
        let requests = document.getElementById("req_url").querySelectorAll('select');
        for (i of requests) {   // For each one of the path selects
                i.addEventListener("change", function() {
                reqUpdate(this.id);     // Adds the method "reqUpdate", with the id associated
                });
        }
        // Fills the content of the Request Path while the user selects different values
        function reqUpdate(UpdatingId){
            console.log(reqUpdate)
            id = parseInt(UpdatingId.split("req")[1], 10);   // Gets the number of the iterator needed to fill

            for (let i = id + 1; i <= 15; i++){ // Deletes all claims depending the new value to fill them later
                document.getElementById("req"+i).style.display = "none";
                document.getElementById("req"+i).innerHTML = "";
                document.getElementById("req"+i).value = "";
            }
            
            if (document.getElementById(UpdatingId).value != ""){   // If the value selected is not "-", if it is "-", nothing more is showed
                
                let nextClaims = dataTree; // Get next claims from dataTree
                let signalPath = "";    // Path to the signal
                for (let i = 0; i <= id; i++){  // Iterates the data tree to get the next claims needed
                    nextClaims = nextClaims[document.getElementById("req"+i).value];
                    signalPath += document.getElementById("req"+i).value + "."; 
                }

                selecttoFill = document.getElementById("req"+(id+1)) // Fills the next select
                if ((nextClaims != undefined)){ //If there are other claims to add (is a parent node)
                    let signals = [[],[],[]];   // Stores the signals in an array depending on the type (contained in at, in purposelist or neither)
                    selecttoFill.style.display = "block";
                    for (let key in nextClaims){
                        // First, needs to get the signal path to check if is avaliable
                        let signalPathComplete = signalPath + key;
                        let option = '<option value = "' + key + '">' + key + '</option>'
                        if (isSignalinAtNoTrust(signalPathComplete)){
                            signals[0].push(option);
                        } else if (isSignalinPurposeListNoTrust(signalPathComplete)){
                            signals[1].push(option);
                        } else {
                            signals[2].push(option);
                        }
                    }
                    // Fills the select using optgroup
                    selecttoFill.insertAdjacentHTML("beforeend", '<option value = "">' + "-" + '</option>');
                    selecttoFill.insertAdjacentHTML("beforeend", '<optgroup label="Avaliable using AT" class = "green_text">');
                    for (let opt of signals[0]){
                        selecttoFill.insertAdjacentHTML("beforeend", opt);
                    }
                    selecttoFill.insertAdjacentHTML("beforeend", '</optgroup>');
                    selecttoFill.insertAdjacentHTML("beforeend", '<optgroup label="Avaliable requesting AT" class = "yellow_text">');
                    for (let opt of signals[1]){
                        selecttoFill.insertAdjacentHTML("beforeend", opt);
                    }
                    selecttoFill.insertAdjacentHTML("beforeend", '</optgroup>');
                    selecttoFill.insertAdjacentHTML("beforeend", '<optgroup label="Not avaliable for you" class = "red_text">');
                    for (let opt of signals[2]){
                        selecttoFill.insertAdjacentHTML("beforeend", opt);
                    }
                    selecttoFill.insertAdjacentHTML("beforeend", '</optgroup>');
                }
            }

        }
        </script>

        <!-- Visual scripts for UI-->
        <script>
            // Fills the method select depending on the protocol selected
            document.getElementById("protocol").addEventListener("change", methodFiller);
            methodFiller(); 
            function methodFiller(){    // Fills the Methods options depending on the selection
                let method = document.getElementById("method")
                switch (document.getElementById("protocol").value){
                    case "HTTP":
                        method.innerHTML = '<option value = "Authorized Read">Authorized Read</option>';
                        method.insertAdjacentHTML("beforeend", '<option value = "Search Read">Search Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "History Read">History Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Signal Discovery Read">Signal Discovery Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Dynamic Metadata Read">Dynamic Metadata Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Authorized Update">Authorized Update</option>');
                        break;
                    case "WS":
                        method.innerHTML = '<option value = "Authorized Read">Authorized Read</option>';
                        method.insertAdjacentHTML("beforeend", '<option value = "Search Read">Search Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "History Read">History Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Signal Discovery Read">Signal Discovery Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Authorized Update">Authorized Update</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Authorized Subscribe">Authorized Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Curve Logging Subscribe">Curve Logging Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Range Subscribe">Range Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Change Subscribe">Change Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Unsubscribe">Unsubscribe</option>');
                        break;
                    case "MQTT":
                        method.innerHTML = ""
                        break;
                }
            }

            // Adds event listener to show filters if requested
            const filter_typ_list = document.getElementById("filters").querySelectorAll('input[type="radio"]');
            for (i of filter_typ_list) {
                    i.addEventListener("change", function() {
                        for (o of filter_typ_list){
                            if (o.checked && o.id!="no_filt"){
                                document.getElementById(o.id + "_input").style.display = "block";
                            } else if (o.id != "no_filt"){
                                document.getElementById(o.id + "_input").style.display = "none";
                            }
                        }
                }   );
            }

            // Shows the possible parameters to change after choosing a request method
            document.getElementById("method").addEventListener("change", function() {
                hideId("url_col");
                hideId("update_div");
                hideId("filter_col");
                hideId("timebased_div");
                hideId("change_div");
                hideId("none_div");
                hideId("path_div");
                hideId("subs_id_col");
                checkId("no_filt", true);
                switch (document.getElementById("method").value) {
                    case "Authorized Read": // Request with no filters
                        showId("url_col");
                        break;
                    case "Search Read":
                        showId("url_col");
                        showId("filter_col");
                        showId("path_div");
                        checkId("paths_filt", true);
                        break;
                    /*case "History Read":
                    case "Signal Discovery Read":
                    case "Dynamic Metadata Read":
                    */
                    case "Authorized Update":
                        showId("update_div");
                        showId("url_col");
                        break;
                    case "Authorized Subscribe" :
                        showId("filter_col");
                        //showId("path_div");
                        showId("timebased_div");
                        showId("change_div");
                        showId("none_div");
                        showId("url_col");
                        break;
                    //case "Curve Logging Subscribe":
                    //case "Range Subscribe":
                    case "Change Subscribe":
                        showId("filter_col");
                        showId("url_col");
                        showId("change_div");
                        checkId("change_filt", true);
                        break;
                    case "Unsubscribe":
                        showId("subs_id_col");
                        break;
                    default:
                        window.alert("Method "+ document.getElementById("method").value +" NOT avaliable");
                }
            })
        </script>


        <!-- Request maker-->
        <script>  
            // Obtains both HTTP, WebSockets, AGT and A urls from clientscripts file 
            const httpURL = (urlMap.tls ? "https://" : "http://") + urlMap.VissIp + ":" + urlMap.VissHttpPort;
            const wsURL = (urlMap.tls ? "wss://" : "ws://") + urlMap.VissIp + ":" + urlMap.VissWsPort;  
            const AgtUrl = (urlMap.tls ? "https://": "http://") + urlMap.AgtIp + ":" + urlMap.AgtPort + "/agts";
            const AtUrl = (urlMap.tls ? "https://" : "http://") + urlMap.AtIp + ":" + urlMap.AtPort + "/ats"

            // Initializes the connection with the server using WS 
            var socket = initializeWebSocket()  // SOCKET can be used to send data
            function initializeWebSocket(){
                logStatus("Info", "Opening WebSocket Connection to "+ wsURL);
                let socket = new WebSocket(wsURL, "VISSv2");
                socket.onmessage = function(event){
                    logStatus("Info", "WS Data Received from: " + event.origin + " Data: " + event.data);
                    prettyResponseWriter(event.data, "WebSockets");
                }
                socket.onopen = function() {
                    logStatus("Info", "Opened WebSocket Connection to " + wsURL);
                }
                socket.onclose = function(event) {
                    logStatus("Info", "WebSocket Connection closed");
                }
                socket.onerror = function(event){
                    logStatus("Error", "WebSocket Connection error");
                    console.log("WS Error: ");
                    console.log(event);
                }
                return socket;
            }

            // Se lanza al pulsar el boton send, envia la request segun el protocol usado
            
            async function sendVissReq(){
                let path = generatePath();
                let accessToken = document.getElementById("at_switch").checked ? await getAtforPath(path):undefined;
                
                try{
                    switch (document.getElementById("protocol").value){
                    // HTTP REQUESTS
                        case "HTTP":
                            let xhttpreq = new XMLHttpRequest();
                            xhttpreq.onreadystatechange = function(){
                                if (this.readyState == 4){
                                    if (this.status != 200){
                                        logStatus("Error", "HTTP Request status: "+this.status+",data: "+this.statusText);
                                    } else{
                                        logStatus("Info", "HTTP Response received: "+this.responseText);
                                        prettyResponseWriter(this.responseText, "HTTP");
                                    }
                                }
                            }
                            let toPretty = {    // To pretty write the request
                                action: ""
                            }
                            let httpReqUrl;
                            switch (document.getElementById("method").value){
                                case "Authorized Read":
                                case "Search Read":
                                    let filter = generateFilter();
                                    httpReqUrl = httpURL + path + filter;
                                    logStatus("Info", "Sending GET Request:" + httpReqUrl)
                                    xhttpreq.open("GET", httpReqUrl, true);
                                    accessToken == undefined ? xhttpreq.setRequestHeader("Authorization", "Bearer "+accessToken) : null; 
                                        // Pretty print the request
                                        toPretty.action = "get";
                                        if (filter != ""){
                                            let filt = filter.replace("?filter=", "");
                                            toPretty.filter = JSON.parse(filt);
                                        }
                                        toPretty.path = path;
                                        prettyRequestWriter(toPretty, "HTTP");
                                    xhttpreq.send();
                                    break;
                                case "Authorized Update":
                                    httpReqUrl = httpURL+path;
                                    let httpReqBody = "{\"value\": \"" + document.getElementById("update_input").value + "\"}";
                                    logStatus("Info", "Sending POST Request:" + httpReqUrl + "; Body: " + httpReqBody);
                                    accessToken == undefined ? xhttpreq.setRequestHeader("Authorization", "Bearer "+accessToken) : null;
                                    xhttpreq.open("POST", httpReqUrl, true);
                                    toPretty.action = "post";
                                    toPretty.path = path;
                                    toPretty.value = document.getElementById("update_input").value;
                                    prettyRequestWriter(toPretty, "HTTP");
                                    xhttpreq.send(httpReqBody);
                                    break;
                                default:
                                    window.alert("AGAIN, METHOD NOT SUPPORTED, WAKE UP!");
                                    return;
                            }
                            break;
                        case "MQTT":
                            window.alert("Protocol MQTT NOT supported");
                            break;
                    // WebSockets Requests
                        case "WS":
                            var params = {
                                action: "",
                                path: generatePath(),
                                "authorization": accessToken,
                                //filter: generateFilter(),
                                requestId: (Math.trunc(Math.random()*65536)).toString()
                            }
                            switch (document.getElementById("method").value){
                                case "Authorized Read":
                                    params.action = "get";
                                    break;
                                case "Search Read":
                                    params.action = "get";
                                    params.filter = generateFilter();
                                    break;
                                case "Authorized Subscribe":
                                case "Change Subscribe":
                                    params.action = "subscribe";
                                    params.filter = generateFilter();
                                    break;
                                case "Authorized Update":
                                    params.action = "set";
                                    params.value = document.getElementById("update_input").value;
                                    break;
                                case "Unsubscribe":
                                    delete params.path;
                                    params.action = "unsubscribe";
                                    params.subscriptionId = document.getElementById("sub_id").value;
                                    break;
                                default:
                                    window.alert("AGAIN, METHOD NOT SUPPORTED, WAKE UP!");
                                    return;
                            }
                            let reqContent = JSON.stringify(params);
                            logStatus("Info", "Sending WS Subscribe Request to " + wsURL + ": " + reqContent);
                            prettyRequestWriter(params, "WebSockets");
                            socket.send(reqContent);
                            break;
                    }
                } catch (err){
                    logStatus("Error", err.message);
                    console.log(err)
                }
            }

            // Shows the pretty request
            function prettyRequestWriter(request, protocol){
                var toWrite;
                switch (protocol){
                    case "HTTP":
                        toWrite = generateReqTableHead(protocol, request.action.toUpperCase(), new Date().toISOString())
                        break;
                    case "WebSockets":
                        toWrite = generateReqTableHead(protocol, request.action.toUpperCase() + " ID: " + request.requestId, new Date().toISOString())
                        break;
                }
                switch (request.action){
                    case "get":
                    case "subscribe":
                        if (request.filter != undefined && request.filter.value.length != undefined){
                            toWrite += generateTableRow(request.path, "Filter: " + request.filter.type + ": "  + JSON.stringify(request.filter.value[0]), "")
                            for (let cont = 1; cont < request.filter.value.length; cont++){
                                toWrite += generateTableRow("", "Filter: " + request.filter.type + ": " + JSON.stringify(request.filter.value[cont]), "")
                            }
                        } else if (request.filter != undefined ){
                            toWrite += generateTableRow(request.path, " Filter: " + request.filter.type + ": " + JSON.stringify(request.filter.value), "")
                        } else{
                            toWrite += generateTableRow(request.path, "", "")
                        }
                        break;
                    case "set":
                    case "post":
                        toWrite += generateTableRow(request.path, request.value, "")
                        break;
                    case "unsubscribe":
                        toWrite += generateTableRow("Unsubscribe from subscription ID " + request.subscriptionId,"", "")
                        break;
                }
                document.getElementById("messages").insertAdjacentHTML("afterbegin",toWrite+"</table>\n");
                
            }

            // Shows the pretty response, need to obtain response in string and protocol used to request
            function prettyResponseWriter(response, respProto){
                objResp = JSON.parse(response);
                var toWrite;
                switch (respProto){
                    case "HTTP":
                        if (objResp.error != null){ // Error response
                            toWrite = generateRespTableHead(respProto, "Error response", objResp.ts);
                            toWrite += generateTableRow("Error", objResp.error.message + "  " + objResp.error.reason, "");
                        } else if (objResp.data != null){   // Ok response
                            toWrite = generateRespTableHead(respProto, "GET OK", objResp.ts);
                            if (objResp.data.length == undefined){  // It is only one data, no need to iterate
                                toWrite += generateTableRow(objResp.data.path, objResp.data.dp.value, objResp.data.dp.ts);
                            } else {
                                for (let con = 0; con < objResp.data.length; con++){
                                    toWrite += generateTableRow(objResp.data[con].path, objResp.data[con].dp.value, objResp.data[con].dp.ts);
                                }
                            }
                        } else{ // OK update response
                            toWrite = generateRespTableHead(respProto, "UPDATE OK", objResp.ts);
                            toWrite += generateTableRow("Update Request Successful","", "");
                        }
                    break;
                    case "WebSockets":
                        if (objResp.error != null){ // Error response
                            let reqInfo;
                            if (objResp.requestId != undefined){
                                reqInfo = "RequestID: " + objResp.requestId;
                                if (objResp.subscriptionId != undefined){
                                    reqInfo += ", SubscriptionID: " + objResp.subscriptionId;
                                }
                            } else {
                                reqInfo = "SubscriptionID: " + objResp.suscriptionId;
                            }
                            toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + "  " + reqInfo, objResp.ts);
                            toWrite += generateTableRow("Error "+objResp.error.number, objResp.error.message + " " + objResp.error.reason, "");
                        } else{ // Ok messages
                            switch(objResp.action){
                                case "get":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", ID " + objResp.requestId, objResp.ts);
                                    if (objResp.data.length == undefined){  // It is only one data, no need to iterate
                                        toWrite += generateTableRow(objResp.data.path, objResp.data.dp.value, objResp.data.dp.ts);
                                    } else {
                                        for (let con = 0; con < objResp.data.length; con++){
                                            toWrite += generateTableRow(objResp.data[con].path, objResp.data[con].dp.value, objResp.data[con].dp.ts);
                                        }
                                    }
                                    break;
                                case "subscribe":   // Subscription ok
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", Request ID: " + objResp.requestId, objResp.ts);
                                    toWrite += generateTableRow("Subscription Request Accepted", "Subscription ID: " + objResp.subscriptionId, "")
                                    break;
                                case "subscription":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + " ID: " + objResp.subscriptionId, objResp.ts);
                                    if (objResp.data.length == undefined){  // It is only one data, no need to iterate
                                        toWrite += generateTableRow(objResp.data.path, objResp.data.dp.value, objResp.data.dp.ts);
                                    } else {
                                        for (let con = 0; con < objResp.data.length; con++){
                                            toWrite += generateTableRow(objResp.data[con].path, objResp.data[con].dp.value, objResp.data[con].dp.ts);
                                        }
                                    }
                                    break;
                                case "set":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", ID " + objResp.requestId, objResp.ts);
                                    toWrite += generateTableRow("Update Request Successful","", "");
                                    break;
                                case "unsubscribe":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", RequestID: " + objResp.requestId, objResp.ts);
                                    toWrite += generateTableRow("Unsubscribe Request Successful", "Unsubscribed from ID: " + objResp.subscriptionId, "");
                                    break;
                                default:
                                    logStatus("Info", "Invalid response received from WebSockets");
                            }
                        }
                    break;
                }
                document.getElementById("messages").insertAdjacentHTML("afterbegin",toWrite+"</table>\n");
            }


            // generates Header of the response table  
            function generateRespTableHead(respProto, respTyp, respTs){
                return "<table class = \"rcv_table\" width = \"70%\" id = \"" +  + "\">\n"        // Usable to delete the response selected
                +"	<colgroup>\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\">\n"
                +"	</colgroup>\n"
                +"<tr>\n"
                +"	    <th colspan=8>" + respProto + "</td>\n"
                +"	    <th colspan=6>" + respTyp + "</td>\n"
                +"	    <th class = \"response_ts\" colspan=6 >" + respTs + "</td>\n"
                +"	</tr>\n";
            }
            // generates Header of request table 
            function generateReqTableHead(reqProto, reqTyp, reqTs){
                return "<table class = \"snd_table\" width = \"70%\" id = \"" +  + "\">\n"        // Usable to delete the response selected
                +"	<colgroup>\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\">\n"
                +"	</colgroup>\n"
                +"<tr>\n"
                +"	    <th colspan=8>" + reqProto + "</td>\n"
                +"	    <th colspan=6>" + reqTyp + "</td>\n"
                +"	    <th class = \"request_ts\" colspan=6 >" + reqTs + "</td>\n"
                +"	</tr>\n";
            }
            // generates a row of data 
            function generateTableRow(titl, val, tims){
                return "	<tr>\n"
                +"	    <td class = \"response_typ\" colspan = 8>" + titl + "</td>\n"
                +"	    <td class = \"response_msg\" colspan = 8>" + val + "</td>\n"
                +"	    <td class = \"response_data_ts\" colspan = 4>" + tims + "</td> \n"
                +"	</tr> \n";
            }
            // Obtains the path of the request using the selects in the HTML
            function generatePath(){
                let path = "";
                for (let i = 0; i <= 15; i++){
                    let val = document.getElementById("req"+i).value;
                    if (val == ""){
                        break;
                    }
                    path = path + "/" + val;
                }
                return path;
            }
            // Returns the content of the filter
            function generateFilter(){
                var filtMap = {};
                if (document.getElementById("timebased_filt").checked){
                    filtMap.type = "timebased";
                    let valueMap = {};
                    valueMap.period = document.getElementById("timebased_filt_period").value;
                    filtMap.value = valueMap;
                }else if (document.getElementById("paths_filt").checked){
                    filtMap.type = "paths";
                    let valueMap = [];
                    let valMapCont = 0;
                    let pathInputCont = 1;
                    while(document.getElementById("path_filt_" + pathInputCont)){
                        if(document.getElementById("path_filt_" + pathInputCont).value != ""){
                            valueMap[valMapCont] = document.getElementById("path_filt_" + pathInputCont).value;
                            valMapCont++;
                        }
                        pathInputCont++;
                    }
                    filtMap.value = valueMap;
                } else if (document.getElementById("change_filt").checked){
                    filtMap.type = "change";
                    let valueMap = {};
                    valueMap["logic-op"] = document.getElementById("change_filt_operator").value;
                    valueMap["diff"] = document.getElementById("change_filt_difference").value;
                    filtMap.value = valueMap;
                } else if (document.getElementById("no_filt").checked){
                    return "";
                }
                let filtString = JSON.stringify(filtMap);
                if (filtString != ""){
                    switch (document.getElementById("protocol").value){
                        case "HTTP":
                            return "?filter="+filtString;
                            break;
                        case "WS":
                            return filtMap;
                            break;
                        default:
                            return null;
                    }
                }
            }        
        </script>
    </body>
</html>