<!DOCTYPE html>

<html>
	<head>
        <title>VISS Web Client - VISS Request</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="icon" href="images/favicon.ico">
        <link rel="stylesheet" href="styles/menu.css" type="text/css">
		<link rel="stylesheet" href="styles/general.css" type="text/css">
        <script src = "scripts/js/encoding.js"></script>
        <script src = "scripts/js/logger.js"></script>
        <script src = "scripts/js/clientscripts.js"></script>
        <script src = "scripts/js/tokenhandler.js"></script>
	</head>
	<body>
        <script src = "scripts/js/menu.js"></script>
		<h2>VISS Client</h2><br>
        <div id = gt_opts class="vert_select_list">
            <p class="subject">VISS Request</p>
            <div class = "row">
                <div class = "column" style="width: 15%;">
                    <label for = "token">Access Token</label>
                    <br><select id = "token" name = "token">
                        <option value = "None">None</option>
                    </select>
                    <label for = "protocol">Protocol</label>
                    <br><select id = "protocol" name = "protocol">
                        <option value = "HTTP">HTTP</option>
                        <option value = "WS">WebSocket</option>
                        <option value = "MQTT">MQTT</option>
                    </select>
                    <label for = "method">Method</label>
                    <br><select id = "method" name = "method"></select>
                    <div style="font-size: 10px;"> Note: Only Few Methods Supported at the moment </div>
                    <br>
                    <input type="checkbox" id="log_switch" checked> <span>Logs</span>
                    <input type="checkbox" id="at_switch" checked> <span>AT</span>
                    <br>
                    <button onclick="sendVissReq()" class="arrow_button"><span>Send</span></button>  
                </div>
                <div class="column" id = "url_col" style="width: 15%;">
                    <div id = "req_url">
                        <label for = "req0">Request URL</label>
                        <br><select id = "req0" name = "token">
                            <option value = "">-</option>
                        </select>
                        <select id = "req1" name = "token" style="display: none;"></select>
                        <select id = "req2" name = "token" style="display: none;"></select>
                        <select id = "req3" name = "token" style="display: none;"></select>
                        <select id = "req4" name = "token" style="display: none;"></select>
                        <select id = "req5" name = "token" style="display: none;"></select>
                        <select id = "req6" name = "token" style="display: none;"></select>
                        <select id = "req7" name = "token" style="display: none;"></select>
                        <select id = "req8" name = "token" style="display: none;"></select>
                        <select id = "req9" name = "token" style="display: none;"></select>
                        <select id = "req10" name = "token" style="display: none;"></select>
                        <select id = "req11" name = "token" style="display: none;"></select>
                        <select id = "req12" name = "token" style="display: none;"></select>
                        <select id = "req13" name = "token" style="display: none;"></select>
                        <select id = "req14" name = "token" style="display: none;"></select>
                        <select id = "req15" name = "token" style="display: none;"></select>
                    </div> 
                    <div id = "update_div" style="display: none;">
                        <label for = "update_input">Update Value</label>
                        <input type = "text" id = "update_input">
                    </div>           
                </div>
                <div class="column" id = "subs_id_col" style="width: 15%; display: none;">
                    <label for = "sub_id">Subscription ID</label>
                    <input type = "text" id = "sub_id">
                </div>
                
                <div class = "column" id = "filter_col" style="width: 15%; display: none;">
                    <label for = "filters">Filters</label>
                    <dl id = "filters">
                        <dt id = "timebased_div">
                            <label for = "timebased_filt">Timebased</label>
                            <input type="radio" id="timebased_filt" name = "filt_radio" unchecked>
                            <div id = "timebased_filt_input" style="display: none;">
                                <label for = "timebased_filt_period">Period (ms): </label>
                                <input type = "text" id = "timebased_filt_period" placeholder="time between updates" >
                            </div>
                        </dt>
                        <dt id = "path_div">
                            <label for = "paths_filt">Paths</label> 
                            <input type="radio" id = "paths_filt" name = "filt_radio" unchecked>
                            <div id = "paths_filt_input" style="display: none;">
                                <input type = "text" id = "path_filt_1" placeholder="path1">
                                <input type = "text" id = "path_filt_2" placeholder="path2">
                                <input type = "text" id = "path_filt_3" placeholder="path3">
                            </div>
                        </dt>
                        <dt id = "change_div">
                            <label for = "change_filt">Change</label>
                            <input type="radio" id="change_filt" name = "filt_radio" unchecked>
                            <div id = "change_filt_input" style="display: none;">
                                <label for = "change_filt_operator">Operator:</label>
                                <select id = "change_filt_operator" name = "change_filt_operator">
                                    <option value = "gt">Greather than (false -> true)</option>
                                    <option value = "lt">Lower than (true -> false)</option>
                                    <option value = "ne">Not equal (both)</option>
                                    <option value = "gte">Greather than or equal</option>
                                    <option value = "lte">Lower than or equal</option>
                                </select>
                                <label for = "change_filt_difference">Difference: </label>
                                <input type = "text" id = "change_filt_difference">
                            </div>
                        </dt>
                        <dt id = "none_div">
                            <label for = "no_filt">None</label>
                            <input type = "radio" id = "no_filt" name = "filt_radio" checked>
                        </dt>
                    </dl>                    
                </div>
                <div class="column" id="at_col" style="width: 20%;">
                    <div class="data_box_bordered">
                        <p class="subject" id = "Token" style="margin: 5px; padding:0px; padding-bottom:2px">Access Token</p>
                        <pre id = "TokenContent" class="data"></pre>
                    </div>
                </div>
                <div class="column" style = "width: 50%">
                    <div class="data_box_bordered" id="logs">
                        <p class="subject">Logs 
                            <button onclick="logReset()">Reset</button> 
                        </p> 
                        <p id="log_data" class="data" style="display: block; overflow-y: scroll; height: 200px;"></p>
                    </div> 
                </div>
            </div>
        </div> 
        <div class = "message_list" id = "message_list">
            <p class = "subject">Response List</p>
            <div class = "messages" id = "messages"></div>
        </div>
        
        
        <!---

                sssssss ccccccc rrrrrrr  ii  ppppppp ttttttt sssssss 
                ss      cc      rr   rr  ii  pp   pp   ttt   ss      
                sssssss cc      rrrrrrr  ii  ppppppp   ttt   sssssss 
                     ss cc      rr rr    ii  pp         tt        ss 
                sssssss ccccccc rr  rrr  ii  pp         ttt  sssssss 

        -->


        <!-- Initialization-->
        <script>
        // Fills the Selector for the Access Grant Tokens Avaliable
            var atList; // LIST OF THE ATS AVALIABLE
            atFiller();
            function atFiller(){
                let atPromList = getAtList().then(function(atPromList){    // Calls a function that returns all the tokens avaliable
                    atPromList.forEach(at => {    // If all ok, iterates the list and shows the ids in the select
                        document.getElementById("token").insertAdjacentHTML("beforeend", '<option value = "' + at.tokenId + '">' + 
                            at.tokenId + '</option>');
                    });
                    atList = atPromList;
                }, function(atPromList){   // Error getting list
                    window.alert("Error getting AT list");
                    logStatus("Error", "Error getting AT List: " + atPromList, "console");
                })
            }

        //  Shows AT depending on the AT selected 
            document.getElementById("token").addEventListener("change", showAT);
            function showAT(){
                document.getElementById("TokenContent");
                let tokenId = document.getElementById("token").value; // ID of the token requested
                if (tokenId == "None" || atList == undefined){ // If no at is selected or no agtlist is avaliable
                    document.getElementById("TokenContent").innerHTML = "";
                } else {   // A token has been selected
                    const hasId = (element) => element.tokenId == tokenId;  // Function to use in findIndex 
                    let at = atList.find(hasId); // Searchs the array to find the token with the id selected
                    console.log(at)
                    console.log(JSON.stringify(at.header, null, "  <br>")  + JSON.stringify(at.payload, null, "  "))
                    document.getElementById("TokenContent").innerHTML = JSON.stringify(at.header, null, " ") + "<br>" + JSON.stringify(at.payload, null, " ");
                }
            }
        </script>


        <!-- Dynamic items in page-->
        <script>
            // Shows the methods avaliable depending on the protocol selected
            document.getElementById("protocol").addEventListener("change", methodFiller);
            methodFiller(); 
            function methodFiller(){    // Fills the Methods options depending on the selection
                let method = document.getElementById("method")
                switch (document.getElementById("protocol").value){
                    case "HTTP":
                        method.innerHTML = '<option value = "Authorized Read">Authorized Read</option>';
                        method.insertAdjacentHTML("beforeend", '<option value = "Search Read">Search Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "History Read">History Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Signal Discovery Read">Signal Discovery Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Dynamic Metadata Read">Dynamic Metadata Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Authorized Update">Authorized Update</option>');
                        break;
                    case "WS":
                        method.innerHTML = '<option value = "Authorized Read">Authorized Read</option>';
                        method.insertAdjacentHTML("beforeend", '<option value = "Search Read">Search Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "History Read">History Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Signal Discovery Read">Signal Discovery Read</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Authorized Update">Authorized Update</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Authorized Subscribe">Authorized Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Curve Logging Subscribe">Curve Logging Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Range Subscribe">Range Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Change Subscribe">Change Subscribe</option>');
                        method.insertAdjacentHTML("beforeend", '<option value = "Unsubscribe">Unsubscribe</option>');
                        break;
                    case "MQTT":
                        method.innerHTML = ""
                        break;
                }
            }

            // Initializes the Path using the vsspathlist.json
            var dataTree = treeInit()
            function treeInit(){    
                let xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        let helptree = JSON.parse(xhr.responseText)
                        dataTree = pathListJson(JSON.stringify(helptree["LeafPaths"]))
                        for (let key in dataTree){
                            document.getElementById("req0").insertAdjacentHTML("beforeend", '<option value = "' + key + '">' + key + '</option>');
                        }
                    }
                }
                xhr.open('GET', 'specs/vsspathlist.json');
                xhr.send();
            }

            // Adds listener for the path filler 
            let requests = document.getElementById("req_url").querySelectorAll('select');
            for (i of requests) {
                    i.addEventListener("change", function() {
                    reqUpdate(this.id); 
                }   );
            }
            // Fills the content of the Request Path while the user selects different values
            function reqUpdate(UpdatingId){
                let id = UpdatingId.split("req");
                id = parseInt(id[1], 10);
                for (let i = id + 1; i <= 15; i++){ // Deletes all claims dependent of it
                    document.getElementById("req"+i).style.display = "none";
                    document.getElementById("req"+i).innerHTML = "";
                    document.getElementById("req"+i).value = "";
                }
                
                let nextClaims = dataTree; // Get next claims from dataTree
                for (let i = 0; i <= id; i++){
                    nextClaims = nextClaims[document.getElementById("req"+i).value];
                }

                seltoAdd = document.getElementById("req"+(id+1)) // Fills the next select
                if ((nextClaims != undefined) && (document.getElementById("req"+id).value != "")){ //If it exist and the value 
                    seltoAdd.style.display = "block";
                    for (let key in nextClaims){
                        seltoAdd.insertAdjacentHTML("afterbegin", '<option value = "' + key + '">' + key + '</option>');
                    }
                    seltoAdd.insertAdjacentHTML("afterbegin", '<option value = "">' + "-" + '</option>');
                }
            }
            
            // Dynamic filter content
            const filter_typ_list = document.getElementById("filters").querySelectorAll('input[type="radio"]');
            for (i of filter_typ_list) {
                    i.addEventListener("change", function() {
                        for (o of filter_typ_list){
                            if (o.checked && o.id!="no_filt"){
                                document.getElementById(o.id + "_input").style.display = "block";
                            } else if (o.id != "no_filt"){
                                document.getElementById(o.id + "_input").style.display = "none";
                            }
                        }
                }   );
            }

            function showId(id){
                document.getElementById(id).style.display = "block";
            }
            function hideId(id){
                document.getElementById(id).style.display = "none";
            }
            function checkId(id, checked){  // Checks an input, triggering the onchange event
                document.getElementById(id).checked = checked;
                let evnt = document.createEvent("HTMLEvents");
                evnt.initEvent("change", false, true);
                document.getElementById(id).dispatchEvent(evnt);
            }
            function triggerOnChange(id){
                let evnt = document.createEvent("HTMLEvents");
                evnt.initEvent("change", false, true)
                document.getElementById(id).dispatchEvent(evnt);
            }


            // Used for showing request claims to fill after selecting the method
            document.getElementById("method").addEventListener("change", function() {
                hideId("url_col");
                hideId("update_div");
                hideId("filter_col");
                hideId("timebased_div");
                hideId("change_div");
                hideId("none_div");
                hideId("path_div");
                hideId("subs_id_col");
                checkId("no_filt", true);
                switch (document.getElementById("method").value) {
                    case "Authorized Read": // Request with no filters
                        showId("url_col");
                        break;
                    case "Search Read":
                        showId("url_col");
                        showId("filter_col");
                        showId("path_div");
                        checkId("paths_filt", true);
                        break;
                    /*case "History Read":
                    case "Signal Discovery Read":
                    case "Dynamic Metadata Read":
                    */
                    case "Authorized Update":
                        showId("update_div");
                        showId("url_col");
                        break;
                    case "Authorized Subscribe" :
                        showId("filter_col");
                        //showId("path_div");
                        showId("timebased_div");
                        showId("change_div");
                        showId("none_div");
                        showId("url_col");
                        break;
                    //case "Curve Logging Subscribe":
                    //case "Range Subscribe":
                    case "Change Subscribe":
                        showId("filter_col");
                        showId("url_col");
                        showId("change_div");
                        checkId("change_filt", true);
                        break;
                    case "Unsubscribe":
                        showId("subs_id_col");
                        break;
                    default:
                        window.alert("Method "+ document.getElementById("method").value +" NOT avaliable");
                }
            })

        </script>

        <!-- Request maker-->
        <script>  
            // Obtains both HTTP and WebSockets urls from clientscripts file 
            const httpURL = (urlMap.tls ? "https://" : "http://") + urlMap.VissIp + ":" + urlMap.VissHttpPort;
            const wsURL = (urlMap.tls ? "wss://" : "ws://") + urlMap.VissIp + ":" + urlMap.VissWsPort;  
            
            // Initializes the connection with the server using WS 
            var socket = initializeWebSocket()  // SOCKET can be used to send data
            function initializeWebSocket(){
                logStatus("Info", "Opening WebSocket Connection to "+ wsURL);
                let socket = new WebSocket(wsURL, "VISSv2");
                socket.onmessage = function(event){
                    logStatus("Info", "WS Data Received from: " + event.origin + " Data: " + event.data);
                    prettyResponseWriter(event.data, "WebSockets");
                }
                socket.onopen = function() {
                    logStatus("Info", "Opened WebSocket Connection to " + wsURL);
                }
                socket.onclose = function(event) {
                    logStatus("Info", "WebSocket Connection closed");
                }
                socket.onerror = function(event){
                    logStatus("Error", "WebSocket Connection error");
                    console.log("WS Error: ");
                    console.log(event);
                }
                return socket;
            }

            // Env√≠a un mensaje dependiendo del protocolo usado
            try {
                function sendVissReq(){
                    let path = generatePath();  // Generates the Request Path
                    let selectedAt = getAt();        // Obtains the access token
                    switch (document.getElementById("protocol").value){
                    // HTTP REQUESTS
                        case "HTTP":
                            let xhttpreq = new XMLHttpRequest();
                            xhttpreq.onreadystatechange = function(){
                                if (this.readyState == 4){
                                    if (this.status != 200){
                                        logStatus("Error", "HTTP Request status: "+this.status+",data: "+this.statusText);
                                    } else{
                                        logStatus("Info", "HTTP Response received: "+this.responseText);
                                        prettyResponseWriter(this.responseText, "HTTP");
                                    }
                                }
                            }

                            let toPretty = { }   // Var used to show the request
                            let httpReqUrl; // URL including the path
                            
                            switch (document.getElementById("method").value){
                                case "Authorized Read":
                                case "Search Read":
                                    filter = generateFilter();
                                    httpReqUrl = httpURL+path+filter;
                                    logStatus("Info", "Sending GET Request:" + httpReqUrl)
                                    xhttpreq.open("GET", httpReqUrl, true);
                                    selectedAt != "" ? xhttpreq.setRequestHeader("Authorization", "Bearer " + selectedAt) : null;
                                        toPretty.action = "get";
                                        filter!="" ? toPretty.filter = JSON.parse(filter.replace("?filter=","")):null; 
                                        toPretty.path = path;
                                        prettyRequestWriter(toPretty, "HTTP");
                                    xhttpreq.send();
                                    break;
                                case "Authorized Update":
                                    httpReqUrl = httpURL+path;
                                    let httpReqBody = "{\"value\": \"" + document.getElementById("update_input").value + "\"}";
                                    logStatus("Info", "Sending POST Request:" + httpReqUrl + "; Body: " + httpReqBody);
                                    xhttpreq.open("POST", httpReqUrl, true);
                                    selectedAt != "" ? xhttpreq.setRequestHeader("Authorization", "Bearer " + selectedAt) : null;
                                        toPretty.action = "post";
                                        toPretty.path = path;
                                        toPretty.value = document.getElementById("update_input").value;
                                        prettyRequestWriter(toPretty, "HTTP");
                                    xhttpreq.send(httpReqBody);
                                    break;
                                default:
                                    window.alert("AGAIN, METHOD NOT SUPPORTED, WAKE UP!");
                                    return;
                            }
                            break;
                        case "MQTT":
                            window.alert("Protocol MQTT NOT supported");
                            break;
                    // WebSockets Requests
                        case "WS":
                            var params = {
                                action: "",
                                path: generatePath(),
                                //"authorization": 
                                //filter: generateFilter(),
                                requestId: (Math.trunc(Math.random()*65536)).toString(),
                                authorization: selectedAt
                            }
                            switch (document.getElementById("method").value){
                                case "Authorized Read":
                                    params.action = "get";
                                    break;
                                case "Search Read":
                                    params.action = "get";
                                    params.filter = generateFilter();
                                    break;
                                case "Authorized Subscribe":
                                case "Change Subscribe":
                                    params.action = "subscribe";
                                    params.filter = generateFilter();
                                    break;
                                case "Authorized Update":
                                    params.action = "set";
                                    params.value = document.getElementById("update_input").value;
                                    break;
                                case "Unsubscribe":
                                    delete params.path;
                                    params.action = "unsubscribe";
                                    params.subscriptionId = document.getElementById("sub_id").value;
                                    break;
                                default:
                                    window.alert("AGAIN, METHOD NOT SUPPORTED, WAKE UP!");
                                    return;
                            }
                            let reqContent = JSON.stringify(params);
                            logStatus("Info", "Sending WS Subscribe Request to " + wsURL + ": " + reqContent);
                            prettyRequestWriter(params, "WebSockets");
                            socket.send(reqContent);
                            break;
                    }
                }
            } catch (err){
                logStatus("Error", err.message);
            }

            // Shows the pretty request
            function prettyRequestWriter(request, protocol){
                var toWrite;
                switch (protocol){
                    case "HTTP":
                        toWrite = generateReqTableHead(protocol, request.action.toUpperCase(), new Date().toISOString())
                        break;
                    case "WebSockets":
                        toWrite = generateReqTableHead(protocol, request.action.toUpperCase() + " ID: " + request.requestId, new Date().toISOString())
                        break;
                }
                switch (request.action){
                    case "get":
                    case "subscribe":
                        console.log(request)
                        if (request.filter != undefined && request.filter.value.length != undefined){
                            toWrite += generateTableRow(request.path, "Filter: " + request.filter.type + ": "  + JSON.stringify(request.filter.value[0]), "")
                            for (let cont = 1; cont < request.filter.value.length; cont++){
                                toWrite += generateTableRow("", "Filter: " + request.filter.type + ": " + JSON.stringify(request.filter.value[cont]), "")
                            }
                        } else if (request.filter != undefined ){
                            toWrite += generateTableRow(request.path, " Filter: " + request.filter.type + ": " + JSON.stringify(request.filter.value), "")
                        } else{
                            toWrite += generateTableRow(request.path, "", "")
                        }
                        break;
                    case "set":
                    case "post":
                        toWrite += generateTableRow(request.path, request.value, "")
                        break;
                    case "unsubscribe":
                        toWrite += generateTableRow("Unsubscribe from subscription ID " + request.subscriptionId,"", "")
                        break;
                }
                document.getElementById("messages").insertAdjacentHTML("afterbegin",toWrite+"</table>\n");
                
            }

            // Shows the pretty response, need to obtain response in string and protocol used to request
            function prettyResponseWriter(response, respProto){
                objResp = JSON.parse(response);
                var toWrite;
                switch (respProto){
                    case "HTTP":
                        if (objResp.error != null){ // Error response
                            toWrite = generateRespTableHead(respProto, "Error response", objResp.ts);
                            toWrite += generateTableRow("Error", objResp.error.message + "  " + objResp.error.reason, "");
                        } else if (objResp.data != null){   // Ok response
                            toWrite = generateRespTableHead(respProto, "GET OK", objResp.ts);
                            if (objResp.data.length == undefined){  // It is only one data, no need to iterate
                                toWrite += generateTableRow(objResp.data.path, objResp.data.dp.value, objResp.data.dp.ts);
                            } else {
                                for (let con = 0; con < objResp.data.length; con++){
                                    toWrite += generateTableRow(objResp.data[con].path, objResp.data[con].dp.value, objResp.data[con].dp.ts);
                                }
                            }
                        } else{ // OK update response
                            toWrite = generateRespTableHead(respProto, "UPDATE OK", objResp.ts);
                            toWrite += generateTableRow("Update Request Successful","", "");
                        }
                    break;
                    case "WebSockets":
                        if (objResp.error != null){ // Error response
                            let reqInfo;
                            if (objResp.requestId != undefined){
                                reqInfo = "RequestID: " + objResp.requestId;
                                if (objResp.subscriptionId != undefined){
                                    reqInfo += ", SubscriptionID: " + objResp.subscriptionId;
                                }
                            } else {
                                reqInfo = "SubscriptionID: " + objResp.suscriptionId;
                            }
                            toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + "  " + reqInfo, objResp.ts);
                            toWrite += generateTableRow("Error "+objResp.error.number, objResp.error.message + " " + objResp.error.reason, "");
                        } else{ // Ok messages
                            switch(objResp.action){
                                case "get":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", ID " + objResp.requestId, objResp.ts);
                                    if (objResp.data.length == undefined){  // It is only one data, no need to iterate
                                        toWrite += generateTableRow(objResp.data.path, objResp.data.dp.value, objResp.data.dp.ts);
                                    } else {
                                        for (let con = 0; con < objResp.data.length; con++){
                                            toWrite += generateTableRow(objResp.data[con].path, objResp.data[con].dp.value, objResp.data[con].dp.ts);
                                        }
                                    }
                                    break;
                                case "subscribe":   // Subscription ok
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", Request ID: " + objResp.requestId, objResp.ts);
                                    toWrite += generateTableRow("Subscription Request Accepted", "Subscription ID: " + objResp.subscriptionId, "")
                                    break;
                                case "subscription":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + " ID: " + objResp.subscriptionId, objResp.ts);
                                    if (objResp.data.length == undefined){  // It is only one data, no need to iterate
                                        toWrite += generateTableRow(objResp.data.path, objResp.data.dp.value, objResp.data.dp.ts);
                                    } else {
                                        for (let con = 0; con < objResp.data.length; con++){
                                            toWrite += generateTableRow(objResp.data[con].path, objResp.data[con].dp.value, objResp.data[con].dp.ts);
                                        }
                                    }
                                    break;
                                case "set":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", ID " + objResp.requestId, objResp.ts);
                                    toWrite += generateTableRow("Update Request Successful","", "");
                                    break;
                                case "unsubscribe":
                                    toWrite = generateRespTableHead(respProto, objResp.action.toUpperCase() + ", RequestID: " + objResp.requestId, objResp.ts);
                                    toWrite += generateTableRow("Unsubscribe Request Successful", "Unsubscribed from ID: " + objResp.subscriptionId, "");
                                    break;
                                default:
                                    logStatus("Info", "Invalid response received from WebSockets");
                            }
                        }
                    break;
                }
                document.getElementById("messages").insertAdjacentHTML("afterbegin",toWrite+"</table>\n");
            }


            // generates Header of the response table  
            function generateRespTableHead(respProto, respTyp, respTs){
                return "<table class = \"rcv_table\" width = \"70%\" id = \"" +  + "\">\n"        // Usable to delete the response selected
                +"	<colgroup>\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\">\n"
                +"	</colgroup>\n"
                +"<tr>\n"
                +"	    <th colspan=8>" + respProto + "</td>\n"
                +"	    <th colspan=6>" + respTyp + "</td>\n"
                +"	    <th class = \"response_ts\" colspan=6 >" + respTs + "</td>\n"
                +"	</tr>\n";
            }
            // generates Header of request table 
            function generateReqTableHead(reqProto, reqTyp, reqTs){
                return "<table class = \"snd_table\" width = \"70%\" id = \"" +  + "\">\n"        // Usable to delete the response selected
                +"	<colgroup>\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\"><col width=\"5%\">\n"
                +"	    <col width=\"5%\"><col width=\"5%\">\n"
                +"	</colgroup>\n"
                +"<tr>\n"
                +"	    <th colspan=8>" + reqProto + "</td>\n"
                +"	    <th colspan=6>" + reqTyp + "</td>\n"
                +"	    <th class = \"request_ts\" colspan=6 >" + reqTs + "</td>\n"
                +"	</tr>\n";
            }
            // generates a row of data 
            function generateTableRow(titl, val, tims){
                return "	<tr>\n"
                +"	    <td class = \"response_typ\" colspan = 8>" + titl + "</td>\n"
                +"	    <td class = \"response_msg\" colspan = 8>" + val + "</td>\n"
                +"	    <td class = \"response_data_ts\" colspan = 4>" + tims + "</td> \n"
                +"	</tr> \n";
            }
            // Obtains the path of the request using the selects in the HTML
            function generatePath(){
                let path = "";
                for (let i = 0; i <= 15; i++){
                    let val = document.getElementById("req"+i).value;
                    if (val == ""){
                        break;
                    }
                    path = path + "/" + val;
                }
                return path;
            }
            // Returns the content of the filter
            function generateFilter(){
                var filtMap = {};
                if (document.getElementById("timebased_filt").checked){
                    filtMap.type = "timebased";
                    let valueMap = {};
                    valueMap.period = document.getElementById("timebased_filt_period").value;
                    filtMap.value = valueMap;
                }else if (document.getElementById("paths_filt").checked){
                    filtMap.type = "paths";
                    let valueMap = [];
                    let valMapCont = 0;
                    let pathInputCont = 1;
                    while(document.getElementById("path_filt_" + pathInputCont)){
                        if(document.getElementById("path_filt_" + pathInputCont).value != ""){
                            valueMap[valMapCont] = document.getElementById("path_filt_" + pathInputCont).value;
                            valMapCont++;
                        }
                        pathInputCont++;
                    }
                    filtMap.value = valueMap;
                } else if (document.getElementById("change_filt").checked){
                    filtMap.type = "change";
                    let valueMap = {};
                    valueMap["logic-op"] = document.getElementById("change_filt_operator").value;
                    valueMap["diff"] = document.getElementById("change_filt_difference").value;
                    filtMap.value = valueMap;
                } else if (document.getElementById("no_filt").checked){
                    return "";
                }
                let filtString = JSON.stringify(filtMap);
                if (filtString != ""){
                    switch (document.getElementById("protocol").value){
                        case "HTTP":
                            return "?filter="+filtString;
                            break;
                        case "WS":
                            return filtMap;
                            break;
                        default:
                            return null;
                    }
                }
            }
            // Returns the access token (if selected)
            function getAt(){
                if (document.getElementById("token").value == "None"){ // No at selected
                    return ""
                } else{
                    let atselected = atList.find(element => element.tokenId == document.getElementById("token").value);
                    return atselected.encoded;
                }
            }
            
        </script>
    </body>
</html>